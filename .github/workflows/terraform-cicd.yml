# .github/workflows/terraform-cicd.yml
name: Terraform CI/CD (main)

on:
  pull_request:
    paths:
      - 'chapter0/**'
      - 'app/**'
      - '.github/workflows/terraform-cicd.yml'
  push:
    branches: [ main ]
    paths:
      - 'chapter0/**'
      - 'app/**'
      - '.github/workflows/terraform-cicd.yml'
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  plan:
    name: Plan
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: chapter0
    outputs:
      no_changes: ${{ steps.tfplan.outputs.no_changes }}
    env:
      TF_IN_AUTOMATION: true
      TF_INPUT: false
      AWS_REGION: ap-northeast-1
      TF_VAR_name_prefix: aws-study-tf
      TF_VAR_cidr_block: 10.0.0.0/16
      TF_VAR_instance_type: t3.micro
      TF_VAR_key_name: ${{ secrets.TF_KEY_NAME }}
      TF_VAR_my_home_ip: ${{ secrets.TF_MY_HOME_IP }}
      TF_VAR_db_username: ${{ secrets.DB_USERNAME }}
      TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
      TF_VAR_notification_email: ${{ secrets.NOTIFICATION_EMAIL }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (OIDC, PLAN role)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_TF_PLAN }}
          aws-region: ap-northeast-1

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.6

      - name: Terraform fmt/validate/test
        run: |
          terraform fmt -check -recursive
          terraform init -input=false -no-color
          terraform validate -no-color
          terraform test -no-color

      - name: terraform plan (detailed-exitcode, pipefail)
        id: tfplan
        run: |
          set -euo pipefail
          terraform plan -no-color -out=tfplan -input=false -detailed-exitcode > plan_raw.txt || ec=$?
          ec=${ec:-0}

          if [ "$ec" -eq 0 ]; then
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
          elif [ "$ec" -eq 2 ]; then
            echo "no_changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "::error::terraform plan failed (exit 1). See plan_raw.txt for details."
            exit 1
          fi

          terraform show -no-color tfplan > plan.txt

      - name: Debug conditions (after plan)
        run: |
          echo "event=${{ github.event_name }}"
          echo "ref=${{ github.ref }}"
          echo "steps.tfplan.outputs.no_changes=${{ steps.tfplan.outputs.no_changes }}"

      - uses: actions/upload-artifact@v4
        if: success()
        with:
          name: tfplan
          path: |
            chapter0/tfplan
            chapter0/plan.txt
            chapter0/plan_raw.txt
          retention-days: 7

  apply:
    name: Apply + Deploy (main only)
    needs: plan
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production
    defaults:
      run:
        working-directory: chapter0
    env:
      TF_IN_AUTOMATION: true
      TF_INPUT: false
      AWS_REGION: ap-northeast-1
      TF_VAR_name_prefix: aws-study-tf
      TF_VAR_cidr_block: 10.0.0.0/16
      TF_VAR_instance_type: t3.micro
      TF_VAR_key_name: ${{ secrets.TF_KEY_NAME }}
      TF_VAR_my_home_ip: ${{ secrets.TF_MY_HOME_IP }}
      TF_VAR_db_username: ${{ secrets.DB_USERNAME }}
      TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
      TF_VAR_notification_email: ${{ secrets.NOTIFICATION_EMAIL }}

      # Spring Boot プロジェクトがある場所（違うならここだけ変える）
      SPRING_APP_DIR: app

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (OIDC, APPLY role)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_TF_APPLY }}
          aws-region: ap-northeast-1

      - uses: actions/download-artifact@v4
        with:
          name: tfplan
          path: chapter0

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.6

      - name: terraform init
        run: terraform init -input=false -no-color

      - name: terraform apply
        run: terraform apply -input=false tfplan

      # ---- 「EC2確認 + Spring Boot配備」 ----

      - name: Read outputs (EC2 ip/sg)
        run: |
          set -euo pipefail
          echo "EC2_IP=$(terraform output -raw ec2_public_ip)" >> $GITHUB_ENV
          echo "EC2_SG=$(terraform output -raw ec2_sg_id)" >> $GITHUB_ENV

      - name: Allow SSH from runner (temporary)
        run: |
          set -euo pipefail
          RUNNER_IP=$(curl -s https://checkip.amazonaws.com)/32
          echo "RUNNER_IP=$RUNNER_IP" >> $GITHUB_ENV

          aws ec2 authorize-security-group-ingress \
            --group-id "$EC2_SG" \
            --ip-permissions "IpProtocol=tcp,FromPort=22,ToPort=22,IpRanges=[{CidrIp=$RUNNER_IP,Description=gha-temp}]" \
          || true

      - name: Write SSH key
        run: |
          set -euo pipefail
          KEY_PATH="$RUNNER_TEMP/key.pem"
          # base64 で保存している秘密鍵を復号してファイルに書き出す
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY_B64 }}" | base64 -d > "$KEY_PATH"
          chmod 400 "$KEY_PATH"
          echo "KEY_PATH=$KEY_PATH" >> $GITHUB_ENV

      - name: Wait for SSH
        run: |
          set -euo pipefail
          for i in {1..30}; do
            echo "[$i/30] Trying SSH to $EC2_IP ..."
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -i "$KEY_PATH" ec2-user@"$EC2_IP" "echo ok"; then
              echo "SSH is ready"
              exit 0
            fi
            echo "SSH not ready yet, retrying in 10s..."
            sleep 10
          done
          echo "SSH not ready after 30 attempts"
          exit 1

      - name: Verify Ansible/Java (cloud-init)
        run: |
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i "$KEY_PATH" ec2-user@"$EC2_IP" '
            set -euxo pipefail
            ansible --version || true
            java -version || true
            sudo tail -n 150 /var/log/cloud-init-output.log || true
          '

      - name: Setup Java for build
        uses: actions/setup-java@v4
        with:
          distribution: corretto
          java-version: "21"

      - name: Build Spring Boot jar
        working-directory: ${{ env.SPRING_APP_DIR }}
        run: |
          set -euo pipefail
          chmod +x ./gradlew
          ./gradlew clean bootJar
          JAR=$(ls build/libs/*.jar | grep -v plain | head -n 1)
          echo "JAR=$PWD/$JAR" >> $GITHUB_ENV

      - name: Copy jar to EC2
        run: |
          set -euo pipefail
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i "$KEY_PATH" "$JAR" ec2-user@"$EC2_IP":/home/ec2-user/app.jar

      - name: Deploy & start Spring Boot via Ansible (DB + app + systemd)
        run: |
          set -euo pipefail

          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i "$KEY_PATH" ec2-user@"$EC2_IP" 'bash -s' <<'REMOTE'
          set -euxo pipefail

          # --- Ansible がなければ入れる ---
          if ! command -v ansible >/dev/null 2>&1; then
            sudo dnf -y install ansible
          fi

          # --- Corretto 21 がまだ入っていないときだけインストール ---
          if ! rpm -q java-21-amazon-corretto-devel >/dev/null 2>&1; then
            echo "java-21-amazon-corretto-devel not installed, installing..."
            sudo dnf -y install java-21-amazon-corretto-devel || {
              echo "WARN: dnf install java-21-amazon-corretto-devel failed (maybe already installed). Continue."
            }
          else
            echo "java-21-amazon-corretto-devel already installed, skip dnf"
          fi

          # inventory（EC2 内で localhost 用）
          cat >/home/ec2-user/inventory.ini <<'EOF'
          [local]
          localhost ansible_connection=local
          EOF

          # DB + app + systemd まで全部やる playbook
          cat >/home/ec2-user/deploy.yml <<'YAML'
          - hosts: local
            become: true
            vars:
              db_name: awsstudy
              db_user: admin
              db_pass: "Admin12345!"
              mysql_root_pass: "RootPass123!"   # ★追加：root の本番パスワード

            tasks:
              # --- MySQL インストール＆起動 ---
              - name: Install MySQL repo (if not exists)
                ansible.builtin.command: >
                  dnf -y install https://dev.mysql.com/get/mysql84-community-release-el9-1.noarch.rpm
                args:
                  creates: /etc/yum.repos.d/mysql-community.repo

              - name: Install MySQL server
                ansible.builtin.dnf:
                  name: mysql-community-server
                  state: present

              - name: Enable and start mysqld
                ansible.builtin.service:
                  name: mysqld
                  state: started
                  enabled: true

             # --- 初回起動時の一時パスワードを拾う ---
             - name: Get temporary root password (may be empty on rerun)
               ansible.builtin.shell: "grep 'temporary password' /var/log/mysqld.log | tail -1 | awk '{print $NF}' || true"
               register: mysql_temp_password
               changed_when: false

             # --- 一時パスワードで root パス変更 + DB + adminユーザー作成を一気にやる ---
             - name: Init MySQL (set root password, create db & admin user)
               ansible.builtin.shell: |
                 mysql --connect-expired-password -u root -p"{{ mysql_temp_password.stdout }}" <<SQL
                 ALTER USER 'root'@'localhost' IDENTIFIED BY '{{ mysql_root_pass }}';

                 CREATE DATABASE IF NOT EXISTS {{ db_name }} DEFAULT CHARACTER SET utf8mb4;

                 CREATE USER IF NOT EXISTS '{{ db_user }}'@'localhost' IDENTIFIED BY '{{ db_pass }}';
                 CREATE USER IF NOT EXISTS '{{ db_user }}'@'%' IDENTIFIED BY '{{ db_pass }}';

                 GRANT ALL PRIVILEGES ON {{ db_name }}.* TO '{{ db_user }}'@'localhost';
                 GRANT ALL PRIVILEGES ON {{ db_name }}.* TO '{{ db_user }}'@'%';
                 FLUSH PRIVILEGES;
                 SQL
               args:
                 executable: /bin/bash
               when: mysql_temp_password.stdout != ""
               failed_when: false        # ★ここを追加

              # --- テーブル作成 & サンプルデータ ---
              - name: Create student table and seed data
                ansible.builtin.shell: |
                  mysql -u {{ db_user }} -p"{{ db_pass }}" {{ db_name }} <<SQL
                  CREATE TABLE IF NOT EXISTS student (
                    id   INT PRIMARY KEY,
                    name VARCHAR(100)
                  );

                  INSERT INTO student (id, name) VALUES (1, 'Kouji Enami')
                    ON DUPLICATE KEY UPDATE name = VALUES(name);
                  SQL
                args:
                  executable: /bin/bash

              # --- アプリ配置 ---
              - name: Create app dir
                ansible.builtin.file:
                  path: /opt/app
                  state: directory
                  mode: "0755"

              - name: Move jar into place
                ansible.builtin.command: mv /home/ec2-user/app.jar /opt/app/app.jar
                args:
                  creates: /opt/app/app.jar

              - name: Ensure ownership
                ansible.builtin.file:
                  path: /opt/app
                  state: directory
                  owner: ec2-user
                  group: ec2-user
                  recurse: true

              # --- application.properties を配置 ---
              - name: Write application.properties
                ansible.builtin.copy:
                  dest: /opt/app/application.properties
                  mode: "0644"
                  content: |
                    spring.datasource.url=jdbc:mysql://localhost:3306/{{ db_name }}?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Tokyo
                    spring.datasource.username={{ db_user }}
                    spring.datasource.password={{ db_pass }}
                    spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

                    mybatis.configuration.map-underscore-to-camel-case=true

              # --- systemd ユニットを配置＆起動 ---
              - name: Create systemd unit for Spring Boot
                ansible.builtin.copy:
                  dest: /etc/systemd/system/springboot.service
                  mode: "0644"
                  content: |
                    [Unit]
                    Description=Spring Boot App
                    After=network.target

                    [Service]
                    Type=simple
                    User=ec2-user
                    WorkingDirectory=/opt/app
                    ExecStart=/usr/bin/java -jar /opt/app/app.jar
                    Restart=always
                    RestartSec=5

                    [Install]
                    WantedBy=multi-user.target

              - name: Enable and start springboot service
                ansible.builtin.systemd:
                  name: springboot
                  enabled: true
                  state: restarted
                  daemon_reload: true
          YAML

          chown ec2-user:ec2-user /home/ec2-user/inventory.ini /home/ec2-user/deploy.yml

          # Playbook 実行
          sudo -u ec2-user ansible-playbook -i /home/ec2-user/inventory.ini /home/ec2-user/deploy.yml

          # 最終確認（ログだけ表示）
          sudo systemctl status springboot --no-pager -l || true
          REMOTE

      - name: Revoke SSH from runner (cleanup)
        if: always()
        run: |
          aws ec2 revoke-security-group-ingress \
            --group-id "$EC2_SG" \
            --ip-permissions "IpProtocol=tcp,FromPort=22,ToPort=22,IpRanges=[{CidrIp=$RUNNER_IP}]" \
          || true

